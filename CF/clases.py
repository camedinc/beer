# -*- coding: utf-8 -*-
"""clases.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12qzcCiU2-h5OJ0a2bmbWKSs74E93qZ_a
"""

# Librerías estandar
import pandas as pd
import os
import matplotlib.pyplot as plt
from scipy.stats import anderson

# Librerías externas
!pip install surprise
from surprise import Reader, Dataset
from surprise.model_selection import train_test_split
from surprise import accuracy
from surprise.prediction_algorithms import SVD, KNNWithMeans, KNNBasic, KNNBaseline
from surprise.model_selection import cross_validate
from surprise.model_selection import GridSearchCV
from surprise.model_selection import KFold

# Clase que carga la data
class CargadorDatos:
  '''Clase que carga datos'''
  def __init__(self, ruta_base):
    ''' Constructor de la clase '''
    self.ruta_base = ruta_base
    self.ruta_movies = os.path.join(ruta_base, 'movies.csv')
    self.ruta_ratings = os.path.join(ruta_base, 'ratings.csv')

  def carga_data(self):
    '''Carga los dataframes'''
    self.df_movies = pd.read_csv(self.ruta_movies)
    self.df_ratings = pd.read_csv(self.ruta_ratings)
    return self.df_movies, self.df_ratings

# Clase que depura las bases
class DepuradorDatos:
  '''Clase que depura los datos'''
  def __init__(self, df_movies, df_ratings):
    self.df_movies = df_movies
    self.df_ratings = df_ratings
    self.df = None
    self.df_depurado = None

  def merge_data(self):
    '''Une los dataframes'''
    self.df = pd.merge(self.df_movies, self.df_ratings, on='movieId', how='right')
    return self.df

  def nombre_columnas(self):
    '''Retorna los nombres de las coumnas'''
    return self.df.columns

  def dimensiones_data(self):
    '''Retorna las dimensiones del dataframe'''
    return self.df.shape

  def ids_unicos(self):
    userId_unicos =  self.df['userId'].nunique()
    movieId_unicos =  self.df['movieId'].nunique()
    return userId_unicos, movieId_unicos

  def group_data(self):
    '''Agrupa los datos y reinicia el indice'''
    self.df = self.df.groupby(['userId', 'movieId', 'title', 'genres'])['rating'].mean().reset_index()
    return self.df

  def count_valoraciones(self):
    '''Cuenta valoraciones por usuario, ordena y selecciona sobre 50'''
    self.df['count_valoraciones'] = self.df.groupby(['userId'])['rating'].transform('count')
    self.df.sort_values(by='count_valoraciones', ascending = False, inplace = True)
    self.df = self.df[self.df['count_valoraciones']>= 50]
    return self.df

  def count_nas(self):
    '''Cuenta valores nulos en el dataframe'''
    df_nas = self.df.isna().sum().to_frame
    return df_nas

  def elimina_nas(self):
    '''Elimina valores NAs'''
    self.df.dropna(inplace = True)
    return self.df

  def count_duplicados(self):
    '''Cuenta valores duplicados en el dataframe'''
    n_duplicados = self.df.duplicated().sum()
    return n_duplicados

  def elimina_duplicados(self):
    '''Elimina valores duplicados'''
    self.df.drop_duplicates(inplace = True)
    return self.df

# Clase estática que genera gráficas (tiene decorador, no lleva constructor ni return)
class GenerarGrafica:
  '''Clase que genera gráficas'''
  @staticmethod
  def histograma(df, columna):
    '''Genera un histograma'''
    df[columna].hist()
    plt.xlabel(columna)
    plt.ylabel("conteo")
    plt.title("Histograma")
    plt.show()

# Clase test
class Test:
  ''' Clase que verifica normalidad'''
  def __init__(self, df):
    self.df = df

  def normalidad(self, columna):
    ''' Verifica normalidad en serie larga'''
    result = anderson(self.df[columna], dist='norm')  # 'dist' especifica distribución, 'norm' para normalidad
    # Interpretación
    if result.statistic < result.critical_values[2]:
      print("Los datos siguen una distribución normal")
    else:
      print("Los datos NO siguen una distribucion normal")
    values = pd.DataFrame({'Estadístico':result.statistic, 'Valor_p':result.critical_values, 'Significancia':result.significance_level})
    return values

# Clase modelo
class Modelo:
  '''Clase que genera el modelo de recomendación'''
  def __init__(self, df): # consructor, df argumento, self.df atributo de clase
    self.df = df
    self.df_modelo = None # inicializa para asegurar que se cree en un método
    self.trainset = None
    self.testset = None
    self.model = None
    self.predictions = None
    self.accuracy = None

  def variables_relevantes(self, columna1, columna2, columna3): # referencia a la instancia y columnas locales de método
    '''Selecciona las variables del modelo'''
    self.df_modelo = self.df.loc[:,[columna1,columna2,columna3]] # self permite que todos los métodos ven los atributos de la instancia
    return self.df_modelo

  def reader(self, scale): # scale es rating_scale como tupla, específico del método reader, de debe declarar
    '''Genera reader y data'''
    reader = Reader(rating_scale=scale)
    self.data = Dataset.load_from_df(self.df_modelo, reader)
    #return self.data

  def train_test_split(self, test_size, random_state):
    '''Genera el train test split'''
    self.trainset, self.testset = train_test_split(self.data, test_size=test_size, random_state=random_state)
    return self.trainset, self.testset

  def model_training(self):
    '''Entrena el modelo'''
    self.model = SVD()
    self.model.fit(self.trainset)
    return self.model

  def model_predictions(self):
    '''Genera las predicciones del modelo'''
    self.predictions = self.model.test(self.testset)
    self.recomendaciones = pd.DataFrame(self.predictions)
    self.recomendaciones = self.recomendaciones.drop(['r_ui', 'details'], axis=1)
    return self.recomendaciones

  def info_movies(self, df_movies):
    self.recomendaciones = pd.merge(self.recomendaciones, df_movies, left_on='iid', right_on='movieId', how='left').reset_index(drop=True)
    return self.recomendaciones